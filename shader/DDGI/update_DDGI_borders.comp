#version 460
#extension GL_GOOGLE_include_directive : enable
#include "../bufferReferences.glsl"
#include "../structs.h"
#include "../formats.h"
#include "../bindlessLayouts.glsl"
#include "../common.glsl"
#include "ddgi_common.glsl"

layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 randomRotation; //Unused here
} constants;

layout(local_size_x_id = 1) in;
layout(local_size_y_id = 2) in;
layout(local_size_z_id = 3) in;
layout(constant_id = 4) const bool columns = false;
layout(constant_id = 5) const bool filterIrradiance = false;
layout(constant_id = 6) const uint imageFormat = R16G16B16A16F;


//struct DDGIVolume {
//	//Assuming Grid
//	float spacingX;
//	float spacingY;
//	float spacingZ;
//
//	float inverseSpacingX;
//	float inverseSpacingY;
//	float inverseSpacingZ;
//
//	float gridOriginX;
//	float gridOriginY;
//	float gridOriginZ;
//
//	uint probeCountX;
//	uint probeCountY;
//	uint probeCountZ;
//
//	uint raysPerProbe;
//
//	//Probe size in px 
//	uint irradianceProbeSize;
//	uint depthProbeSize;
//
//	uint irradianceTextureSizeX;
//	uint irradianceTextureSizeY;
//	float inverseIrradianceTextureSizeX;
//	float inverseIrradianceTextureSizeY;
//	uint irradianceTextureBinding;
//	uint irradianceTextureSampler;
//	uint irradianceImageBinding;
//
//	uint depthTextureSizeX;
//	uint depthTextureSizeY;
//	float inverseDepthTextureSizeX;
//	float inverseDepthTextureSizeY;
//	uint depthTextureBinding;
//	uint depthTextureSampler;
//	uint depthImageBinding;
//
//	float shadowBias;
//	float maxRayDistance;
//	float hysteresis;
//	float irradianceThreshold;
//	float lightToDarkThreshold;
//};
void copy_border_rows(DDGIVolume volume, uvec3 globalId) {
	ivec2 maxSize = ivec2(0);
	int probeSize = 2;
	uint imageBinding = 0;

	if(filterIrradiance) {
		imageBinding = volume.irradianceImageBinding;
		maxSize = ivec2(volume.irradianceTextureSizeX, volume.irradianceTextureSizeY);
		probeSize += int(volume.irradianceProbeSize);
	}
	else {
		maxSize = ivec2(volume.depthTextureSizeX, volume.depthTextureSizeY) ;
		probeSize += int(volume.depthProbeSize);
		imageBinding = volume.depthImageBinding;
	}


	int probeSizeMinusOne = probeSize - 1;
	ivec2 texelCoord = ivec2(globalId.xy);
	texelCoord.y *= probeSize;
	if(any(greaterThanEqual(texelCoord, maxSize)))	return;

	uint probeTexelCoord = texelCoord.x % probeSize;
	if(probeTexelCoord == 0 || probeTexelCoord == probeSizeMinusOne) return;

	//wrap around and use "opposite"
	uint probeStart = uint(texelCoord.x / probeSize) * probeSize;
	uint offset = probeSizeMinusOne - probeTexelCoord;
	
	ivec2 copyLoad = ivec2(probeStart + offset, texelCoord.y +1);
	


	if(imageFormat == R11G11B10F)
		imageStore(imagesR11G11B10F[imageBinding], texelCoord, 
			imageLoad(imagesR11G11B10F[imageBinding], copyLoad));
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesRGB10_A2[imageBinding], texelCoord, 
			imageLoad(imagesRGB10_A2[imageBinding], copyLoad));
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesRGBA16F[imageBinding], texelCoord, 
			imageLoad(imagesRGBA16F[imageBinding], copyLoad));
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesRGBA32F[imageBinding], texelCoord, 
			imageLoad(imagesRGBA32F[imageBinding], copyLoad));

	
	texelCoord.y += probeSizeMinusOne;
	copyLoad = ivec2(probeStart + offset, texelCoord.y - 1);
	
	if(imageFormat == R11G11B10F)
		imageStore(imagesR11G11B10F[imageBinding], texelCoord, 
			imageLoad(imagesR11G11B10F[imageBinding], copyLoad));
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesRGB10_A2[imageBinding], texelCoord, 
			imageLoad(imagesRGB10_A2[imageBinding], copyLoad));
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesRGBA16F[imageBinding], texelCoord, 
			imageLoad(imagesRGBA16F[imageBinding], copyLoad));
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesRGBA32F[imageBinding], texelCoord, 
			imageLoad(imagesRGBA32F[imageBinding], copyLoad));

}

void copy_border_columns(DDGIVolume volume, uvec3 globalId) {
	ivec2 maxSize = ivec2(0);
	int probeSize = 2;
	uint imageBinding = 0;

	if(filterIrradiance) {
		imageBinding = volume.irradianceImageBinding;
		maxSize = ivec2(volume.irradianceTextureSizeX, volume.irradianceTextureSizeY);
		probeSize += int(volume.irradianceProbeSize);
	}
	else {
		imageBinding = volume.depthImageBinding;
		maxSize = ivec2(volume.depthTextureSizeX, volume.depthTextureSizeY) ;
		probeSize += int(volume.depthProbeSize);
	}


	int probeSizeMinusOne = probeSize - 1;
	ivec2 texelCoordFirst = ivec2(globalId.xy);
	texelCoordFirst.x *= probeSize;
	
	if(any(greaterThanEqual(texelCoordFirst, maxSize)))	return;

	ivec2 copyLoadFirst = ivec2(0);
	ivec2 texelCoordSecond = ivec2(0);
	ivec2 copyLoadSecond = ivec2(0);

	int probeTexelCoord = texelCoordFirst.y % probeSize;

	if(probeTexelCoord == 0 || probeTexelCoord == probeSizeMinusOne)
	{
		int probeSizeWithoutBorder = (probeSize - 2);
		copyLoadFirst = ivec2(texelCoordFirst.x + probeSizeWithoutBorder,
						texelCoordFirst.y - sign(probeTexelCoord - 1) * probeSizeWithoutBorder);
		texelCoordSecond = ivec2(texelCoordFirst.x + probeSizeMinusOne, texelCoordFirst.y);
		copyLoadSecond = ivec2(texelCoordSecond.x - probeSizeWithoutBorder, copyLoadFirst.y);
	}
	else {
		uint probeStart = uint(texelCoordFirst.y / probeSize) * probeSize;
		uint offset = probeSizeMinusOne - probeTexelCoord;
		copyLoadFirst = ivec2(texelCoordFirst.x +1, probeStart + offset);
		texelCoordSecond = ivec2(texelCoordFirst.x + probeSizeMinusOne,texelCoordFirst.y); 
		copyLoadSecond = ivec2(texelCoordSecond.x - 1, copyLoadFirst.y);
	}
	

	if(imageFormat == R11G11B10F) {
		imageStore(imagesR11G11B10F[imageBinding], texelCoordFirst, 
			imageLoad(imagesR11G11B10F[imageBinding], copyLoadFirst));
		imageStore(imagesR11G11B10F[imageBinding], texelCoordSecond, 
			imageLoad(imagesR11G11B10F[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R10G10B10A2F) {			
		imageStore(imagesRGB10_A2[imageBinding], texelCoordFirst, 
			imageLoad(imagesRGB10_A2[imageBinding], copyLoadFirst));
		imageStore(imagesRGB10_A2[imageBinding], texelCoordSecond, 
			imageLoad(imagesRGB10_A2[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R16G16B16A16F) {
		imageStore(imagesRGBA16F[imageBinding], texelCoordFirst, 
			imageLoad(imagesRGBA16F[imageBinding], copyLoadFirst));
		imageStore(imagesRGBA16F[imageBinding], texelCoordSecond, 
			imageLoad(imagesRGBA16F[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R32G32B32A32F) {			
		imageStore(imagesRGBA32F[imageBinding], texelCoordFirst, 
			imageLoad(imagesRGBA32F[imageBinding], copyLoadFirst));
		imageStore(imagesRGBA32F[imageBinding], texelCoordSecond, 
			imageLoad(imagesRGBA32F[imageBinding], copyLoadSecond));
	}
	
}

void main()
{
	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];
	if(columns) {
		copy_border_columns(volume, gl_GlobalInvocationID);
	}
	else {
		copy_border_rows(volume, gl_GlobalInvocationID);
	}

}