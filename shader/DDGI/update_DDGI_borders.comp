#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bufferReferences.glsl"
#include "structs.h"
#include "formats.h"
#include "bindlessLayouts.glsl"
#include "common.glsl"
#include "ddgi_common.glsl"
#include "ddgi_push_constants.h"

layout(local_size_x_id = 1) in;
layout(local_size_y_id = 2) in;
layout(local_size_z_id = 3) in;
layout(constant_id = 4) const bool columns = false;
layout(constant_id = 5) const bool filterIrradiance = false;
layout(constant_id = 6) const uint imageFormat = R16G16B16A16F;


void copy_border_rows(DDGIVolume volume, uvec3 globalId) {
	ivec3 maxSize = ivec3(0);
	int probeSize = 2;
	uint imageBinding = 0;

	if(filterIrradiance) {
		imageBinding = volume.irradianceImageBinding;
		maxSize = ivec3(volume.irradianceTextureSizeX, volume.irradianceTextureSizeY, volume.probeCountZ);
		probeSize += int(volume.irradianceProbeSize);
	}
	else {
		imageBinding = volume.depthImageBinding;
		maxSize = ivec3(volume.depthTextureSizeX, volume.depthTextureSizeY, volume.probeCountZ) ;
		probeSize += int(volume.depthProbeSize);
	}


	int probeSizeMinusOne = probeSize - 1;
	ivec3 texelCoord = ivec3(globalId.xyz);
	texelCoord.y *= probeSize;
	if(any(greaterThanEqual(texelCoord, maxSize)))	return;

	uint probeTexelCoord = texelCoord.x % probeSize;
	if(probeTexelCoord == 0 || probeTexelCoord == probeSizeMinusOne) return;

	//wrap around and use "opposite"
	uint probeStart = uint(texelCoord.x / probeSize) * probeSize;
	uint offset = probeSizeMinusOne - probeTexelCoord;
	
	ivec3 copyLoad = ivec3(probeStart + offset, texelCoord.y +1, texelCoord.z);
	

	if(imageFormat == R11G11B10F)
		imageStore(imagesArrayR11G11B10F[imageBinding], texelCoord, 
			imageLoad(imagesArrayR11G11B10F[imageBinding], copyLoad));
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesArrayRGB10_A2[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGB10_A2[imageBinding], copyLoad));
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesArrayRGBA16F[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGBA16F[imageBinding], copyLoad));
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesArrayRGBA32F[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGBA32F[imageBinding], copyLoad));
	else if(imageFormat == E5B9G9R9F)
		imageStore(imagesArrayR32F[imageBinding], texelCoord, 
			imageLoad(imagesArrayR32F[imageBinding], copyLoad));
			
	
	texelCoord.y += probeSizeMinusOne;
	copyLoad = ivec3(probeStart + offset, texelCoord.y - 1, texelCoord.z);
	

	if(imageFormat == R11G11B10F)
		imageStore(imagesArrayR11G11B10F[imageBinding], texelCoord, 
			imageLoad(imagesArrayR11G11B10F[imageBinding], copyLoad));
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesArrayRGB10_A2[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGB10_A2[imageBinding], copyLoad));
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesArrayRGBA16F[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGBA16F[imageBinding], copyLoad));
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesArrayRGBA32F[imageBinding], texelCoord, 
			imageLoad(imagesArrayRGBA32F[imageBinding], copyLoad));
	else if(imageFormat == E5B9G9R9F)
		imageStore(imagesArrayR32F[imageBinding], texelCoord, 
			imageLoad(imagesArrayR32F[imageBinding], copyLoad));

}

void copy_border_columns(DDGIVolume volume, uvec3 globalId) {
	ivec3 maxSize = ivec3(0);
	int probeSize = 2;
	uint imageBinding = 0;

	if(filterIrradiance) {
		imageBinding = volume.irradianceImageBinding;
		maxSize = ivec3(volume.irradianceTextureSizeX, volume.irradianceTextureSizeY, volume.probeCountZ);
		probeSize += int(volume.irradianceProbeSize);
	}
	else {
		imageBinding = volume.depthImageBinding;
		maxSize = ivec3(volume.depthTextureSizeX, volume.depthTextureSizeY, volume.probeCountZ) ;
		probeSize += int(volume.depthProbeSize);
	}


	int probeSizeMinusOne = probeSize - 1;
	ivec3 texelCoordFirst = ivec3(globalId.xyz);
	texelCoordFirst.x *= probeSize;
	
	if(any(greaterThanEqual(texelCoordFirst, maxSize)))	return;
	
	ivec3 copyLoadFirst = ivec3(0);
	ivec3 texelCoordSecond = ivec3(0);
	ivec3 copyLoadSecond = ivec3(0);

	int probeTexelCoord = texelCoordFirst.y % probeSize;

	if(probeTexelCoord == 0 || probeTexelCoord == probeSizeMinusOne)
	{
		int probeSizeWithoutBorder = (probeSize - 2);

		copyLoadFirst = ivec3(texelCoordFirst.x + probeSizeWithoutBorder,
						texelCoordFirst.y - sign(probeTexelCoord - 1) * probeSizeWithoutBorder, texelCoordFirst.z);
		texelCoordSecond = ivec3(texelCoordFirst.x + probeSizeMinusOne, texelCoordFirst.y, texelCoordFirst.z);
		copyLoadSecond = ivec3(texelCoordSecond.x - probeSizeWithoutBorder, copyLoadFirst.y, texelCoordFirst.z);
	}
	else {
		uint probeStart = uint(texelCoordFirst.y / probeSize) * probeSize;
		uint offset = probeSizeMinusOne - probeTexelCoord;

		copyLoadFirst = ivec3(texelCoordFirst.x +1, probeStart + offset, texelCoordFirst.z);
		texelCoordSecond = ivec3(texelCoordFirst.x + probeSizeMinusOne,texelCoordFirst.y, texelCoordFirst.z); 
		copyLoadSecond = ivec3(texelCoordSecond.x - 1, copyLoadFirst.y, texelCoordFirst.z);
	}
	

	if(imageFormat == R11G11B10F) {
		imageStore(imagesArrayR11G11B10F[imageBinding], texelCoordFirst, 
			imageLoad(imagesArrayR11G11B10F[imageBinding], copyLoadFirst));
		imageStore(imagesArrayR11G11B10F[imageBinding], texelCoordSecond, 
			imageLoad(imagesArrayR11G11B10F[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R10G10B10A2F) {			
		imageStore(imagesArrayRGB10_A2[imageBinding], texelCoordFirst, 
			imageLoad(imagesArrayRGB10_A2[imageBinding], copyLoadFirst));
		imageStore(imagesArrayRGB10_A2[imageBinding], texelCoordSecond, 
			imageLoad(imagesArrayRGB10_A2[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R16G16B16A16F) {
		imageStore(imagesArrayRGBA16F[imageBinding], texelCoordFirst, 
			imageLoad(imagesArrayRGBA16F[imageBinding], copyLoadFirst));
		imageStore(imagesArrayRGBA16F[imageBinding], texelCoordSecond, 
			imageLoad(imagesArrayRGBA16F[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == R32G32B32A32F) {			
		imageStore(imagesArrayRGBA32F[imageBinding], texelCoordFirst, 
			imageLoad(imagesArrayRGBA32F[imageBinding], copyLoadFirst));
		imageStore(imagesArrayRGBA32F[imageBinding], texelCoordSecond, 
			imageLoad(imagesArrayRGBA32F[imageBinding], copyLoadSecond));
	}
	else if(imageFormat == E5B9G9R9F) {			
		imageStore(imagesArrayR32F[imageBinding], texelCoordFirst, 
			imageLoad(imagesArrayR32F[imageBinding], copyLoadFirst));
		imageStore(imagesArrayR32F[imageBinding], texelCoordSecond, 
			imageLoad(imagesArrayR32F[imageBinding], copyLoadSecond));
	}
	
}

void main()
{
	DDGIPushConstants constants = pushConstants.constants;
	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];
	if(columns) {
		copy_border_columns(volume, gl_GlobalInvocationID);
	}
	else {
		copy_border_rows(volume, gl_GlobalInvocationID);
	}

}