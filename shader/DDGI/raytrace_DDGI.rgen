#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "../raycommon.glsl"
#include "../bufferReferences.glsl"
#include "../structs.h"
#include "../bindlessLayouts.glsl"
#include "../common.glsl"
#include "../lighting.glsl"
#include "../debug.glsl"
#include "ddgi_common.glsl"
#include "ddgi_sampling.glsl"

layout(location = 0) rayPayloadEXT PackedPayload pld;
//layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT float visibility;

layout(set = 0, binding = 5) uniform accelerationStructureEXT accelerationStructures[ACC_COUNT];


layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 col;
	vec4 randomRotation;
} constants;


float light_visibility(in ShadingData shadingData, in vec3 dir, in float tMax) 
{
    visibility = 0.f;
    uint  rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    float tMin     = 0.02;
	traceRayEXT(accelerationStructures[constants.accBinding], // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            1,              // missIndex
            shadingData.worldPos.xyz + shadingData.shadingNormal * 0.02, // ray origin
            tMin,           // ray min range
            dir.xyz,  // ray direction
            tMax,           // ray max range
            1               // payload (location = 0)
        );
    return visibility;
    //return 1.0f;
}
const float minLight = 1e-5;
vec3 diffuse_point_lights(in Scene scene, in ShadingData shadingData) 
{
    vec3 diffuse = vec3(0.f);
    for(int i = 0; i < maxNumPointLights; i++) 
    {
        PointLight light = scene.pointLights[i];
        vec3 lightDir = light.pos.xyz - shadingData.worldPos;
        float dist = length(lightDir);
        if(dist > light.attenuationDistance)
            continue;

        lightDir /= dist;
        float lightShadow = light_visibility(shadingData, lightDir,dist);
        if(lightShadow <= minLight )
            continue;
        //Falloff borrowed from Real Shading in Unreal Engine 4, Brian Karis 2013 SIGGRAPH
        float distRatio = dist / light.attenuationDistance;
        distRatio *= distRatio;
        distRatio *= distRatio;
        float falloff = clamp(1.f - distRatio, 0.f, 1.f);
        falloff *= falloff;
        falloff *= 1.f / (dist * dist + 1.f);
        LightData lightData;
        lightData.dir = lightDir;
        lightData.intensity = light.intensity * falloff;
        lightData.color = light.color.rgb;
        diffuse += diffuse_light(lightData, shadingData) ;
        
    }
    return diffuse;
}

vec3 diffuse_direct_lighting(in Scene scene, in ShadingData shadingData)
{
    vec3 diffuse = vec3(0.f);
    //Only shade dielectrics
    if(shadingData.metalness >= 1) {
        return vec3(0.f);
    }
    if(scene.dirLight.enabled > 0) 
    {
        float lightShadow = light_visibility(shadingData, -scene.dirLight.dir, 1e27f);
        if(lightShadow > minLight) {
            LightData lightData;
            lightData.dir = scene.dirLight.dir;
            lightData.intensity = scene.dirLight.intensity;
            lightData.color = scene.dirLight.color;
            diffuse += diffuse_light(lightData, shadingData);
        }
    }
    if(scene.numPointLights > 0)
    {
        diffuse += diffuse_point_lights(scene, shadingData);
    }
    return diffuse;
}
#define SAMPLE_DDGI
vec3 diffuse_indirect_lighting(in DDGIVolume volume, in ShadingData shadingData)
{
#ifdef SAMPLE_DDGI
    if(shadingData.metalness < 1.f) {
        vec3 irradiance = sample_ddgi(shadingData.worldPos.xyz, shadingData.shadingNormal, shadingData.shadingNormal, volume);
        vec3 radiance = shadingData.albedo.xyz * irradiance * (1.f - shadingData.metalness)*brdf_lambert(); //Use Lambert, might be interesting to investigate other BRDFs with split sum, but probably not worth it
        return radiance;
    }
#endif
    return vec3(0.f);
}

void main()
{
    //gl_LaunchIDEXT.xy;
    Scene scene = scenes[constants.sceneBinding].scene;
	uint rayIdx = gl_LaunchIDEXT.x;
	uint probeIdx = gl_LaunchIDEXT.y;
	
	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];

	vec3 probeCords = get_probe_coordinates(probeIdx, volume);
	vec3 direction = quaternion_rotate(constants.randomRotation, get_ray_direction(rayIdx, volume));

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.001;
    float tMax     = volume.maxRayDistance;
	traceRayEXT(accelerationStructures[constants.accBinding], // acceleration structure
          rayFlags,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          0,              // missIndex
          probeCords.xyz, // ray origin
          tMin,           // ray min range
          direction.xyz,  // ray direction
          tMax,           // ray max range
          0               // payload (location = 0)
     );
	 Payload payload = unpack_payload(pld);

	 vec3 diffuse = vec3(0.f);
	 vec3 irradiance = vec3(0.f); //Indirect

	 float hitDistance = payload.hitT;

	 if(payload.hitkind == gl_HitKindBackFacingTriangleEXT) 
	 {
		hitDistance *= -0.2;
	 }
	 if(payload.hitkind == HitDDGIMiss) 
	 {
		diffuse = payload.albedo;
		//If miss hitDist = 1e27f for 32-float, less for 16-float 65519, might reconsider 16-bit since rays are filtered
		//hitDistance = 65519.f; 
	 } 
	 else {
        ShadingData shadingData;
        shadingData.albedo = payload.albedo;
        shadingData.alpha = payload.roughness * payload.roughness;
        shadingData.outLightDir = -direction;
        shadingData.metalness = payload.metallic;
        shadingData.shadingNormal = payload.shadingNormal;
        shadingData.worldPos = payload.worldPos;
        //High compile time here, due to point lights (possibly rays in a loop or just the loop alone)
		diffuse += diffuse_direct_lighting(scene, shadingData);
		diffuse += diffuse_indirect_lighting(volume, shadingData);
     }

    hitDistance = min(hitDistance, 65519.f);

#ifdef DEBUG_COLORS
	diffuse = debugColors[probeIdx % debugColors.length()].xyz;
#endif

    imageStore(imagesRGBA16F[constants.renderTarget], ivec2(gl_LaunchIDEXT.xy), vec4(diffuse, hitDistance));
}