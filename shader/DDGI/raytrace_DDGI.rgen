#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "../raycommon.glsl"
#include "../bufferReferences.glsl"
#include "../structs.h"
#include "../bindlessLayouts.glsl"
#include "../common.glsl"
#include "../lighting.glsl"
#include "ddgi_common.glsl"

layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 col;
	vec4 col2;
} constants;

vec3 diffuse_direct_lighting(in Scene scene, in Payload payload)
{
	//TODO
	//Evaluate BRDF and visibility
	return vec3(0.f);
}
vec3 diffuse_indirect_lighting(in Scene scene, in Payload payload)
{
	//TODO
	//Evaluate DDGI
	return vec3(0.f);
}

layout(location = 0) rayPayloadEXT PackedPayload pld;

layout(set = 0, binding = 5) uniform accelerationStructureEXT accelerationStructures[ACC_COUNT];
void main()
{
    //gl_LaunchIDEXT.xy;
    Scene scene = scenes[constants.sceneBinding].scene;
	uint rayIdx = gl_LaunchIDEXT.x;
	uint probeIdx = gl_LaunchIDEXT.y;
	
	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];

	vec3 probeCords = get_probe_coordinates(probeIdx, volume);
	vec3 direction = get_ray_direction(rayIdx, volume);

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.0;
    float tMax     = volume.maxRayDistance;
	traceRayEXT(accelerationStructures[constants.accBinding], // acceleration structure
          rayFlags,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          0,              // missIndex
          probeCords.xyz, // ray origin
          tMin,           // ray min range
          direction.xyz,  // ray direction
          tMax,           // ray max range
          0               // payload (location = 0)
     );
	 Payload payload = unpack_payload(pld);

	 vec3 diffuse = vec3(0.f);
	 vec3 irradiance = vec3(0.f); //Indirect

	 float hitDistance = payload.hitT;

	 if(payload.hitkind == gl_HitKindBackFacingTriangleEXT) 
	 {
		hitDistance *= -0.2;
	 }
	 if(payload.hitkind == HitDDGIMiss) 
	 {
		diffuse = payload.albedo;
		//If miss hitDist = 1e27f for 32-float, less for 16-float 65519, might reconsider 16-bit since rays are filtered
		hitDistance = 65519.f; 
	 } 
	 else {
		diffuse += diffuse_direct_lighting(scene, payload);
		//diffuse += diffuse_indirect_lighting(payload);
	 }

	 imageStore(imagesRGBA16F[constants.renderTarget], ivec2(gl_LaunchIDEXT.xy), vec4(diffuse, hitDistance));
}