#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#include "../raycommon.glsl"
#include "../bufferReferences.glsl"
#include "../structs.h"
#include "../formats.h"
#include "../bindlessLayouts.glsl"
#include "../common.glsl"
#include "../lighting.glsl"
#include "../debug.glsl"
#include "ddgi_common.glsl"
#include "ddgi_sampling.glsl"

layout(location = 0) rayPayloadEXT PackedPayload pld;
//layout(location = 0) rayPayloadEXT Payload payload;
layout(location = 1) rayPayloadEXT float visibility;

layout(set = 0, binding = 5) uniform accelerationStructureEXT accelerationStructures[ACC_COUNT];

layout(constant_id = 1) const uint renderTargetImageFormat = R16G16B16A16F;

layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 randomRotation;
} constants;


float light_visibility(in ShadingData shadingData, in vec3 dir, in float tMax) 
{
    visibility = 0.f;
    uint  rayFlags = gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
    float tMin     = 0.02;
	traceRayEXT(accelerationStructures[constants.accBinding], // acceleration structure
            rayFlags,       // rayFlags
            0xFF,           // cullMask
            0,              // sbtRecordOffset
            0,              // sbtRecordStride
            1,              // missIndex
            shadingData.worldPos.xyz + shadingData.shadingNormal * 0.02, // ray origin
            tMin,           // ray min range
            dir.xyz,  // ray direction
            tMax,           // ray max range
            1               // payload (location = 0)
        );
    return visibility;
    //return 1.0f;
}
const float minLight = 1e-5;
vec3 diffuse_point_lights(in Scene scene, in ShadingData shadingData) 
{
    vec3 diffuse = vec3(0.f);
    for(int i = 0; i < maxNumPointLights; i++) 
    {
        PointLight light = scene.pointLights[i];
        vec3 lightDir = light.pos.xyz - shadingData.worldPos;
        float dist = length(lightDir);
        if(dist > light.attenuationDistance)
            continue;

        lightDir /= dist;
        float lightShadow = light_visibility(shadingData, lightDir,dist);
        if(lightShadow <= minLight )
            continue;
        //Falloff borrowed from Real Shading in Unreal Engine 4, Brian Karis 2013 SIGGRAPH
        float distRatio = dist / light.attenuationDistance;
        distRatio *= distRatio;
        distRatio *= distRatio;
        float falloff = clamp(1.f - distRatio, 0.f, 1.f);
        falloff *= falloff;
        falloff *= 1.f / (dist * dist + 1.f);
        LightData lightData;
        lightData.dir = lightDir;
        lightData.intensity = light.intensity * falloff;
        lightData.color = light.color.rgb;
        diffuse += diffuse_light(lightData, shadingData);
        
    }
    return diffuse;
}

vec3 diffuse_direct_lighting(in Scene scene, in ShadingData shadingData)
{
    vec3 diffuse = vec3(0.f);
    //Only shade dielectrics
    if(shadingData.metalness >= 1) {
        return vec3(0.f);
    }
    if(scene.dirLight.enabled > 0) 
    {
        float lightShadow = light_visibility(shadingData, -scene.dirLight.dir, 1e27f);
        if(lightShadow > minLight) {
            LightData lightData;
            lightData.dir = -scene.dirLight.dir;
            lightData.intensity = scene.dirLight.intensity;
            lightData.color = scene.dirLight.color;
            diffuse += diffuse_light(lightData, shadingData);
        }
    }
    if(scene.numPointLights > 0)
    {
        diffuse += diffuse_point_lights(scene, shadingData);
    }
    return diffuse;
}
//#define SAMPLE_DDGI
vec3 diffuse_indirect_lighting(in DDGIVolume volume, in ShadingData shadingData)
{
//#ifdef SAMPLE_DDGI
    if(shadingData.metalness < 1.f) {
        vec3 irradiance = sample_ddgi(shadingData.worldPos.xyz, shadingData.shadingNormal, shadingData.shadingNormal, volume);
        vec3 radiance = shadingData.albedo.xyz * irradiance * (1.f - shadingData.metalness)*brdf_lambert(); //Use Lambert, might be interesting to investigate other BRDFs with split sum, but probably not worth it
        return radiance;
    }
//#endif
    return vec3(0.f);
}

void main()
{
    //gl_LaunchIDEXT.xy;
    Scene scene = scenes[constants.sceneBinding].scene;
	uint rayIdx = gl_LaunchIDEXT.x;
	uint probeIdx = gl_LaunchIDEXT.y;
	
	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];

	vec3 probeCords = get_probe_coordinates(probeIdx, volume);
	vec3 direction = get_ray_direction(constants.randomRotation, rayIdx, volume);

    uint  rayFlags = gl_RayFlagsNoneEXT;
    float tMin     = 0.001;
    float tMax     = volume.maxRayDistance;
	traceRayEXT(accelerationStructures[constants.accBinding], // acceleration structure
          rayFlags,       // rayFlags
          0xFF,           // cullMask
          0,              // sbtRecordOffset
          0,              // sbtRecordStride
          0,              // missIndex
          probeCords.xyz, // ray origin
          tMin,           // ray min range
          direction.xyz,  // ray direction
          tMax,           // ray max range
          0               // payload (location = 0)
     );
	 Payload payload = unpack_payload(pld);

	 vec3 diffuse = vec3(0.f);

	 float hitDistance = payload.hitT;

	 if(payload.hitkind == gl_HitKindBackFacingTriangleEXT  ) 
	 {
		hitDistance *= -0.2;
	 }
     else {
	     if(payload.hitkind == HitDDGIMiss) 
	     {
		    diffuse = payload.albedo;
		    //If miss hitDist = 1e27f for 32-float, less for 16-float 65519, might reconsider 16-bit since rays are filtered
		    hitDistance = 1e27f; 
	     } 
	     else {
            ShadingData shadingData;
            shadingData.albedo = payload.albedo;
            shadingData.alpha = payload.roughness * payload.roughness;
            shadingData.outLightDir = -direction;
            shadingData.metalness = payload.metallic;
            shadingData.shadingNormal = payload.shadingNormal;
            shadingData.worldPos = payload.worldPos;
            //High compile time here, due to point lights (possibly rays in a loop or just the loop alone)
            //Probable cause was loop end condition in an SSBO
		    diffuse += diffuse_direct_lighting(scene, shadingData);
		    diffuse += diffuse_indirect_lighting(volume, shadingData);
         }
    }
     
	float maxRayDist = get_volume_max_distance(volume); //Get maximum possible distance
    //hitDistance = clamp(hitDistance, -65504.f, 65504.f) ;
    hitDistance = hitDistance / maxRayDist;//Normalize since moments need more accuracy and we have more accuracy in [0;1]
    if(renderTargetImageFormat == R16G16B16A16F) //Not sure if necessary or it gets clamped anyways
        hitDistance = clamp(hitDistance, -65504.f, 65504.f);
    //hitDistance = min(hitDistance, 65504.f);

    #ifdef DEBUG_COLORS
    diffuse = debugColors[probeIdx % debugColors.length()].xyz;
    #endif
    
	if(volume.renderTargetImageFormat == R16G16B16A16F)
        imageStore(imagesRGBA16F[constants.renderTarget], ivec2(gl_LaunchIDEXT.xy), vec4(diffuse, hitDistance));
	else if(volume.renderTargetImageFormat == R32G32B32A32F)
        imageStore(imagesRGBA32F[constants.renderTarget], ivec2(gl_LaunchIDEXT.xy), vec4(diffuse, hitDistance));
}