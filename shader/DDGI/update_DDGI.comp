#version 460
#extension GL_GOOGLE_include_directive : enable
#include "bufferReferences.glsl"
#include "structs.h"
#include "formats.h"
#include "bindlessLayouts.glsl"
#include "common.glsl"
#include "debug.glsl"
#include "ddgi_common.glsl"
#include "packing.glsl"

layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 randomRotation;
} constants;


layout(local_size_x_id = 1) in;
layout(local_size_y_id = 2) in;
layout(local_size_z_id = 3) in;
layout(constant_id = 4) const uint rayCount = 64;
layout(constant_id = 5) const bool filterIrradiance = false;
layout(constant_id = 6) const uint renderTargetImageFormat = R16G16B16A16F;
layout(constant_id = 7) const uint imageFormat = R16G16B16A16F;

//layout(local_size_x = 64) in;
//layout(local_size_y = 1) in;
//layout(local_size_z = 1) in;

//layout(local_size_x = GroupSizeX, local_size_y = GroupSizeY, local_size_z = GroupSizeZ) in; 

shared vec3 rayDirection[rayCount];
shared vec3 rayRadiance[rayCount * (filterIrradiance? 1: 0) + (filterIrradiance? 0: 1)]; //zero sized arrays are apparently not valid SPIR-V
shared float rayDistance[rayCount];


struct MultiscaleMeanEstimatorData
{
  vec3 mean;
  vec3 shortMean;
  float vbbr;
  vec3 variance;
  float inconsistency;
};

void MultiscaleMeanEstimator(vec3 y,
	  inout MultiscaleMeanEstimatorData data,
	  float shortWindowBlend)
{
	vec3 mean = data.mean;
	vec3 shortMean = data.shortMean;
	float vbbr = data.vbbr;
	vec3 variance = data.variance;
	float inconsistency = data.inconsistency;
  
	// Suppress fireflies.
	{
		vec3 dev = sqrt(max(1e-5f.xxx, variance));
		vec3 highThreshold = 0.1 + shortMean + dev * 8;
		vec3 overflow = max(0.f.xxx, y - highThreshold);
		y -= overflow;
	}
  
	vec3 delta = y - shortMean;
	shortMean = mix(shortMean, y, shortWindowBlend);
	vec3 delta2 = y - shortMean;
  
	// This should be a longer window than shortWindowBlend to avoid bias
	// from the variance getting smaller when the short-term mean does.
	float varianceBlend = shortWindowBlend * 0.5;
	variance = mix(variance, delta * delta2, varianceBlend);
	vec3 dev = sqrt(max(1e-5f.xxx, variance));
  
	vec3 shortDiff = mean - shortMean;
  
	float relativeDiff = dot( vec3(0.299f, 0.587f, 0.114f),
		abs(shortDiff) / max(1e-5f.xxx, dev) );
	inconsistency = mix(inconsistency, relativeDiff, 0.08f);
  
	float varianceBasedBlendReduction =
		clamp( dot( vec3(0.299, 0.587, 0.114),
		0.5 * shortMean / max(1e-5f.xxx, dev) ), 1.0/32.f, 1.f );
  
	float catchUpBlend = clamp(smoothstep(0.f, 1.f,
		relativeDiff * max(0.02f, inconsistency - 0.2)), 1.0f/256.f, 1.f);
	catchUpBlend *= vbbr;
  
	vbbr = mix(vbbr, varianceBasedBlendReduction, 0.1);
	mean = mix(mean, y, clamp(catchUpBlend, 0.f, 1.f));
  
	// Output
	data.mean = mean;
	data.shortMean = shortMean;
	data.vbbr = vbbr;
	data.variance = variance;
	data.inconsistency = inconsistency;
}

float max_component(vec3 v) {
	return max(max(v.x, v.y), v.z);
}
//#define DEBUG_COLORS
void main()
{

	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];
	uint probeIdx = get_probe_index(gl_WorkGroupID, volume);

	vec2 uv = vec2(0);
	if(filterIrradiance)
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.irradianceProbeSize));
	else
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.depthProbeSize));

	vec3 texelDir = get_octahedral_direction(uv);
	
	const int iMax = int(ceil(float(rayCount) / float(gl_WorkGroupSize.x * gl_WorkGroupSize.y)));
	const int offset = int(gl_LocalInvocationIndex)* iMax;
	//float maxRayDist = length(get_volume_spacing(volume)) * 2.f;
	for(int i = 0; i < iMax;i++) {
		const int rayIdx = offset + i;
		if(rayIdx >= rayCount) break;
		
		rayDirection[rayIdx] = get_ray_direction(constants.randomRotation, rayIdx, volume);
		vec4 data = vec4(0);
		
		if(renderTargetImageFormat == R16G16B16A16F)
			data = imageLoad(imagesRGBA16F[constants.renderTarget], ivec2(rayIdx, probeIdx));
		else if(renderTargetImageFormat == R32G32B32A32F)
			data = imageLoad(imagesRGBA32F[constants.renderTarget], ivec2(rayIdx, probeIdx));
		
		if(filterIrradiance)
			rayRadiance[rayIdx] = data.xyz;
		rayDistance[rayIdx] = data.w;// *maxRayDist;
	}
	barrier();

	vec4 result = vec4(0.f);
	float resultWeight = 0.f;
	
	int rayIdx = 0;
	if ((volume.relocationEnabled != 0) || (volume.classificationEnabled) != 0)
    {
        rayIdx = int(volume.fixedRayCount);
    }

	uint backfaceCount = 0;
	uint backfaceThreshold = uint(uint( rayCount - rayIdx) * volume.backfaceThreshold);
	for(; rayIdx < rayCount; rayIdx++) {

		vec3 rayDir = rayDirection[rayIdx];
		float rayDist = rayDistance[rayIdx];

		float weight = max(0.f, dot(rayDir, texelDir));
		resultWeight += weight;

		if(filterIrradiance) {
			if(rayDist < 0.f){
				++backfaceCount;
				if( backfaceCount > backfaceThreshold)
					return;
				continue;
			}
			vec3 rayRadiance = rayRadiance[rayIdx];
			result += vec4(rayRadiance * weight, 0.f);
		}
		else {
			rayDist = min(abs(rayDist), 1);
			const float rayDistSqarred = rayDist * rayDist;
			result += vec4(rayDist, rayDistSqarred, rayDistSqarred * rayDist, rayDistSqarred * rayDistSqarred) * weight;
		}
	}
	float epsilon = float(rayCount) * 1e-9f;
	float hysteresis = volume.hysteresis;

	ivec2 texCoord = ivec2(gl_LocalInvocationID.xy + get_probe_texel_coords(ivec3(gl_WorkGroupID.xyz), ivec2(gl_WorkGroupSize.xy), volume));

	float weightNormalization = 1.f/ (max(resultWeight, epsilon));

	if(filterIrradiance)
		weightNormalization *= 0.5f;

	result *= weightNormalization;

	vec4 previous = vec4(0.f);
	uint imageBinding = 0;
	if(filterIrradiance)
		imageBinding = volume.irradianceImageBinding;
	else
		imageBinding = volume.depthImageBinding;
			
	if(imageFormat == R11G11B10F)
		previous = imageLoad(imagesR11G11B10F[imageBinding], texCoord);
	else if(imageFormat == R10G10B10A2F)
		previous = imageLoad(imagesRGB10_A2[imageBinding], texCoord);
	else if(imageFormat == R16G16B16A16F)
		previous = imageLoad(imagesRGBA16F[imageBinding], texCoord);
	else if(imageFormat == R32G32B32A32F)
		previous = imageLoad(imagesRGBA32F[imageBinding], texCoord);
	else if(imageFormat == E5B9G9R9F)
		previous.xyz = rgb9e5_to_vec3(imageLoad(imagesR32UI[imageBinding], texCoord).x);
		//previous.xyz = rgb9e5_to_vec3(floatBitsToUint(imageLoad(imagesR32F[imageBinding], texCoord).x));

	//Recover if we somehow get negativ radiance
	//Shouldn't happen though
	if(dot(previous, previous) <= 0)
		hysteresis = 0.f;

	if(filterIrradiance) {
	
		#undef DO_GAMMA
		//#define DO_GAMMA
		#ifdef DO_GAMMA0
		result.rgb = pow(result.rgb, vec3(1.f / 5.f));
		#endif		

		//MultiscaleMeanEstimator from Ray Tracing Gems
		vec4 data0 = imageLoad(imagesRGBA16F[volume.data0ImageBinding], texCoord);
		vec4 data1 = imageLoad(imagesRGBA16F[volume.data1ImageBinding], texCoord);
		MultiscaleMeanEstimatorData data;
		
		data.mean = previous.xyz;
		data.shortMean = data0.xyz;
		data.vbbr = data0.w;
		data.variance = data1.xyz;
		data.inconsistency = data1.w;

		//MultiscaleMeanEstimator(result.xyz, data, 0.08f);
		MultiscaleMeanEstimator(result.xyz, data, volume.lightToDarkThreshold);
		result = vec4(data.mean, 1.f);

		imageStore(imagesRGBA16F[volume.data0ImageBinding], texCoord, vec4(data.shortMean, data.vbbr));
		imageStore(imagesRGBA16F[volume.data1ImageBinding], texCoord, vec4(data.variance, data.inconsistency));


	//Biased shadow-preserving temporal hysteresis. from GI-1.0
//		float l1 = dot(result.xyz, vec3(1.f / 3.f));
//		float l2 = dot(previous.xyz, vec3(1.f / 3.f));
//
//		float alpha = max(l1 - l2 - min(l1, l2), 0.f) / max(max(l1, l2), 1e-4f);
//		alpha = clamp(alpha, 0.f, 0.95f);
//		alpha *= alpha;
//
//		result = vec4(mix(result.xyz, previous.xyz, alpha), 1.f);


		// From 2021 paper
//		vec3 delta = result.xyz - previous.xyz;
//
//		float changeMagnitude = max_component(abs(-delta));
//		
//		if(changeMagnitude > 0.25)
//			hysteresis = max(0.f, hysteresis - 0.15f);
//
//		if(changeMagnitude > 0.8)
//			hysteresis = 0.f;
//			

//		result.rgb = mix(result.rgb, previous.rgb, hysteresis);
//		result.a = 1.f;


		//From RTXGI SDK
//		vec3 delta = result.xyz - previous.xyz;
//		if(length(delta) > volume.lightToDarkThreshold)
//		{
//			result.rgb = previous.xyz + (delta * 0.25f);
//		}
//		
//		if(max_component(-delta) > volume.irradianceThreshold)
//		{
//			hysteresis = max(0.f, hysteresis - 0.75f);
//		}
//
//
//		const float threshold = 1.f / 1024.f;
//		vec3 lerpDelta = (1.f - hysteresis) * delta;
//		if(max_component(result.xyz) < max_component(previous.xyz))
//		{
//			lerpDelta = clamp(vec3(threshold), abs(lerpDelta), abs(delta)) * sign(lerpDelta);
//		}
//		result = vec4(previous.xyz + lerpDelta, 1.0f);



//Debug checkerboard pattern
//		result = vec4(0, 0, 0, 1);
//		if((((texCoord.x &0x1) == 1)|| ((texCoord.y &0x1) == 1)) && !(((texCoord.x &0x1) == 1) && ((texCoord.y &0x1) == 1)))
//			result = vec4(1, 1,1,1);
//		if((((gl_WorkGroupID.x &0x1) == 1)|| ((gl_WorkGroupID.y &0x1) == 1)) && !(((gl_WorkGroupID.x &0x1) == 1) && ((gl_WorkGroupID.y &0x1) == 1)))
//			result.xy = vec2(1, 0);
//		if((gl_WorkGroupID.z &0x1) == 1)
//			result.z = 1;
#ifdef DEBUG_COLORS
		result = debugColors[probeIdx % debugColors.length()];
#endif
		//result.xyz = vec3(0.1f);
	}
	else {
		result = vec4(mix(result, previous, hysteresis));
	}
	//barrier();
	if(imageFormat == R11G11B10F)
		imageStore(imagesR11G11B10F[imageBinding], texCoord, result);
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesRGB10_A2[imageBinding], texCoord, result);
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesRGBA16F[imageBinding], texCoord, result);
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesRGBA32F[imageBinding], texCoord, result);
	else if(imageFormat == E5B9G9R9F)
		imageStore(imagesR32UI[imageBinding], texCoord, uvec4(vec3_to_rgb9e5(result.rgb), 0, 0,0));
		//imageStore(imagesR32F[imageBinding], texCoord, vec4(uintBitsToFloat(vec3_to_rgb9e5(result.rgb)), 0, 0,0));
	
}