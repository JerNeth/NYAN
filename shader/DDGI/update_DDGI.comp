#version 460
#extension GL_GOOGLE_include_directive : enable
#include "../bufferReferences.glsl"
#include "../structs.h"
#include "../formats.h"
#include "../bindlessLayouts.glsl"
#include "../common.glsl"
#include "../debug.glsl"
#include "ddgi_common.glsl"


layout(std430, push_constant) uniform PushConstants
{
	uint accBinding;
	uint sceneBinding;
	uint meshBinding;
	uint ddgiBinding;
	uint ddgiCount;
	uint ddgiIndex;
	uint renderTarget;
	vec4 col; //Unused here
	vec4 randomRotation;
} constants;


layout(local_size_x_id = 1) in;
layout(local_size_y_id = 2) in;
layout(local_size_z_id = 3) in;
layout(constant_id = 4) const uint rayCount = 64;
layout(constant_id = 5) const bool filterIrradiance = false;
layout(constant_id = 6) const uint renderTarget = R16G16B16A16F;
layout(constant_id = 7) const uint depthFormat = R16G16B16A16F;
layout(constant_id = 8) const uint irradianceFormat = R11G11B10F;

//layout(local_size_x = 64) in;
//layout(local_size_y = 1) in;
//layout(local_size_z = 1) in;

//layout(local_size_x = GroupSizeX, local_size_y = GroupSizeY, local_size_z = GroupSizeZ) in; 

shared vec3 rayDirection[rayCount];
shared vec3 rayRadiance[rayCount * (filterIrradiance? 1: 0) + 1]; //zero sized arrays are not valid SPIR-V
shared float rayDistance[rayCount];


float max_component(vec3 v) {
	return max(max(v.x, v.y), v.z);
}
//#define DEBUG_COLORS
void main()
{

	DDGIVolume volume = ddgiVolumes[constants.ddgiBinding].volume[constants.ddgiIndex];
	uint probeIdx = get_probe_index(gl_WorkGroupID, volume);

	vec2 uv = vec2(0);
	if(filterIrradiance)
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.irradianceProbeSize));
	else
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.depthProbeSize));

	vec3 texelDir = get_octahedral_direction(uv);
	
	const int iMax = int(ceil(float(rayCount) / float(gl_WorkGroupSize.x * gl_WorkGroupSize.y)));
	const int offset = int(gl_LocalInvocationIndex)* iMax;
	//float maxRayDist = length(get_volume_spacing(volume)) * 2.f;
	for(int i = 0; i <iMax;i++) {
		const int rayIdx = offset + i;
		if(rayIdx >= rayCount) break;
		
		rayDirection[rayIdx] = get_ray_direction(constants.randomRotation, rayIdx, volume);
		vec4 data = vec4(0);
		//if(halfRenderTarget)
		data = imageLoad(imagesRGBA16F[constants.renderTarget], ivec2(rayIdx, probeIdx));
		//else
		//	data = imageLoad(imagesRGBA32F[constants.renderTarget], ivec2(rayIdx, probeIdx));
		if(filterIrradiance)
			rayRadiance[rayIdx] = data.xyz;
		rayDistance[rayIdx] = data.w;// *maxRayDist;
	}
	barrier();

	vec4 result = vec4(0.f);
	float resultWeight = 0.f;
	for(int rayIdx = 0; rayIdx < rayCount; rayIdx++) {

		vec3 rayDir = rayDirection[rayIdx];
		float rayDist = rayDistance[rayIdx];

		float weight = max(0.f, dot(rayDir, texelDir));

		if(filterIrradiance) {
			if(rayDist < 0.f){
				continue;
			}
			vec3 rayRadiance = rayRadiance[rayIdx];
			result += vec4(rayRadiance * weight, 0.f);
			resultWeight += weight;
		}
		else {
			rayDist = min(abs(rayDist), 1);
			const float rayDistSqarred = rayDist * rayDist;
			result += vec4(rayDist, rayDistSqarred, rayDistSqarred * rayDist, rayDistSqarred * rayDistSqarred) * weight;
			resultWeight += weight;
		}
	}
	float epsilon = float(rayCount) * 1e-9f;
	float hysteresis = volume.hysteresis;

	ivec2 texCoord = ivec2(gl_LocalInvocationID.xy + get_probe_texel_coords(ivec3(gl_WorkGroupID.xyz), int(gl_WorkGroupSize.x), volume));

	float weightNormalization = 1.f/ (max(resultWeight, epsilon));

	if(filterIrradiance)
		weightNormalization *= 0.5f;

	result *= weightNormalization;

	vec4 previous = vec4(0.f);
	if(filterIrradiance) 
		previous = imageLoad(imagesR11G11B10F[volume.irradianceImageBinding], texCoord);
	else
		previous = imageLoad(imagesRGBA16F[volume.depthImageBinding], texCoord);
	//	previous = imageLoad(imagesRGBA32F[volume.depthImageBinding], texCoord);

	if(dot(previous, previous) == 0)
		hysteresis = 0.f;

	if(filterIrradiance) {

		vec3 delta = result.xyz - previous.xyz;
		if(max_component(-delta) > volume.irradianceThreshold)
		{
			hysteresis = max(0.f, hysteresis - 0.75f);
		}
		if(length(delta) > volume.lightToDarkThreshold)
		{
			result.rgb = previous.xyz + (delta * 0.25f);
		}


		const float threshold = 1.f / 1024.f;
		vec3 lerpDelta = (1.f - hysteresis) * delta;
		if(max_component(result.xyz) < max_component(previous.xyz))
		{
			lerpDelta = clamp(vec3(threshold), abs(lerpDelta), abs(delta)) * sign(lerpDelta);
		}
		result = vec4(previous.xyz + lerpDelta, 1.0f);
//Debug checkerboard pattern
//		result = vec4(0, 0, 0, 1);
//		if((((texCoord.x &0x1) == 1)|| ((texCoord.y &0x1) == 1)) && !(((texCoord.x &0x1) == 1) && ((texCoord.y &0x1) == 1)))
//			result = vec4(1, 1,1,1);
//		if((((gl_WorkGroupID.x &0x1) == 1)|| ((gl_WorkGroupID.y &0x1) == 1)) && !(((gl_WorkGroupID.x &0x1) == 1) && ((gl_WorkGroupID.y &0x1) == 1)))
//			result.xy = vec2(1, 0);
//		if((gl_WorkGroupID.z &0x1) == 1)
//			result.z = 1;
#ifdef DEBUG_COLORS
		result = debugColors[probeIdx % debugColors.length()];
#endif
		imageStore(imagesR11G11B10F[volume.irradianceImageBinding], texCoord, result);
	}
	else {
		result = vec4(mix(result, previous, hysteresis));
		imageStore(imagesRGBA16F[volume.depthImageBinding], texCoord, result);
		//imageStore(imagesRGBA32F[volume.depthImageBinding], texCoord, result);
	}
	
}