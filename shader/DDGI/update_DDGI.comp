#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_shader_subgroup_ballot : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_EXT_shader_atomic_float : enable
#include "bufferReferences.glsl"
#include "structs.h"
#include "formats.h"
#include "bindlessLayouts.glsl"
#include "common.glsl"
#include "debug.glsl"
#include "ddgi_common.glsl"
#include "packing.glsl"
#include "ddgi_push_constants.h"

layout(local_size_x_id = 1) in;
layout(local_size_y_id = 2) in;
layout(local_size_z_id = 3) in;
layout(constant_id = 4) const uint maxRayCount = 64;
layout(constant_id = 5) const bool filterIrradiance = false;
layout(constant_id = 6) const uint renderTargetImageFormat = R16G16B16A16F;
layout(constant_id = 7) const uint imageFormat = R16G16B16A16F;
layout(constant_id = 8) const uint renderTargetImageWidthBits = 10;
layout(constant_id = 9) const uint subgroupSize = 32;
layout(constant_id = 10) const bool dynamicRayAllocationEnabled = false;
layout(constant_id = 11) const bool ReSTIREnabled = false;

shared vec3 rayDirection[maxRayCount];
shared vec3 rayRadiance[maxRayCount * (filterIrradiance? 1: 0) + (filterIrradiance? 0: 1)]; //zero sized arrays are apparently not valid SPIR-V
shared float rayDistance[maxRayCount];
shared float rayVariance; //Unclear whether coherent is needed

struct MultiscaleMeanEstimatorData
{
	vec3 mean;
	vec3 shortMean;
	float vbbr;
	vec3 variance;
	float inconsistency;
};

float MultiscaleMeanEstimator(vec3 y,
	  inout MultiscaleMeanEstimatorData data,
	  float shortWindowBlend)
{
	vec3 mean = data.mean;
	vec3 shortMean = data.shortMean;
	float vbbr = data.vbbr;
	vec3 variance = data.variance;
	float inconsistency = data.inconsistency;
  
	// Suppress fireflies.
	{
		vec3 dev = sqrt(max(1e-5f.xxx, variance));
		vec3 highThreshold = 0.1 + shortMean + dev * 8;
		vec3 overflow = max(0.f.xxx, y - highThreshold);
		y -= overflow;
	}
  
	vec3 delta = y - shortMean;
	shortMean = mix(shortMean, y, shortWindowBlend);
	vec3 delta2 = y - shortMean;
  
	// This should be a longer window than shortWindowBlend to avoid bias
	// from the variance getting smaller when the short-term mean does.
	float varianceBlend = shortWindowBlend * 0.5;
	variance = mix(variance, delta * delta2, varianceBlend);
	vec3 dev = sqrt(max(1e-5f.xxx, variance));
  
	vec3 shortDiff = mean - shortMean;
  
	float relativeDiff = dot( vec3(0.299f, 0.587f, 0.114f),
		abs(shortDiff) / max(1e-5f.xxx, dev) );
	inconsistency = mix(inconsistency, relativeDiff, 0.08f);
  
	float varianceBasedBlendReduction =
		clamp( dot( vec3(0.299, 0.587, 0.114),
		0.5 * shortMean / max(1e-5f.xxx, dev) ), 1.0/32.f, 1.f );
  
	float catchUpBlend = clamp(smoothstep(0.f, 1.f,
		relativeDiff * max(0.02f, inconsistency - 0.2)), 1.0f/256.f, 1.f);
	catchUpBlend *= vbbr;
  
	vbbr = mix(vbbr, varianceBasedBlendReduction, 0.1);
	float blendFactor = clamp(catchUpBlend, 6e-5f, 1.f);
	mean = mix(mean, y, blendFactor);
  
	// Output
	data.mean = mean;
	data.shortMean = shortMean;
	data.vbbr = vbbr;
	data.variance = variance;
	data.inconsistency = inconsistency;
	return blendFactor;
}

//#define DEBUG_COLORS
void main()
{
	DDGIVolume volume = ddgiVolumes[pushConstants.constants.ddgiBinding].volume[pushConstants.constants.ddgiIndex];
	uint probeIdx = get_probe_index(gl_WorkGroupID, volume);
	uint probeCount = volume.probeCountX * volume.probeCountY * volume.probeCountZ;

	vec2 uv = vec2(0);
	if(filterIrradiance)
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.irradianceProbeSize));
	else
		uv = get_normalized_octahedral_coords(ivec2(gl_LocalInvocationID.xy), int(volume.depthProbeSize));

	vec3 texelDir = get_octahedral_direction(uv);

	uint globalRayBeginIdx = probeIdx * volume.raysPerProbe;
	uint rayCount = maxRayCount;
	if(dynamicRayAllocationEnabled) {
        uint probeBegin = readUInts[volume.dynamicRayBufferBinding].u[probeCount + probeIdx];
		uint probeEnd = readUInts[volume.dynamicRayBufferBinding].u[probeCount + probeIdx + 1];
		rayCount = min(int(probeEnd - probeBegin), int(maxRayCount));
		globalRayBeginIdx = probeBegin;
	}

	const int iMax = int(ceil(float(rayCount) / float(gl_WorkGroupSize.x * gl_WorkGroupSize.y)));
	const int offset = int(gl_LocalInvocationIndex)* iMax;
	//float maxRayDist = length(get_volume_spacing(volume)) * 2.f;
	for(int i = 0; i < iMax; i++) {
		const int rayIdx = offset + i;
		if(rayIdx >= rayCount) break;
		
		rayDirection[rayIdx] = get_ray_direction(pushConstants.constants.randomRotation, rayIdx, volume.raysPerProbe, volume);
		vec4 data = vec4(0);
		
		uint globalRayIdx = globalRayBeginIdx + rayIdx;
		ivec2 renderTargetIdx = ivec2(globalRayIdx & ((1 << renderTargetImageWidthBits)-1), globalRayIdx >> renderTargetImageWidthBits );
		if(renderTargetImageFormat == R16G16B16A16F)
			data = imageLoad(imagesRGBA16F[pushConstants.constants.renderTarget], renderTargetIdx);
		else if(renderTargetImageFormat == R32G32B32A32F)
			data = imageLoad(imagesRGBA32F[pushConstants.constants.renderTarget], renderTargetIdx);
		
		if(filterIrradiance)
			rayRadiance[rayIdx] = data.xyz;
		rayDistance[rayIdx] = data.w;// *maxRayDist;
	}
	barrier();

	
	vec4 biasedResult = vec4(0.f);
	if (filterIrradiance && (volume.biasedEstimator != 0)){
		for(int rayIdx = 0; rayIdx < volume.fixedRayCount; rayIdx++) {
			vec3 rayDir = rayDirection[rayIdx];
			float weight = max(0.f, dot(rayDir, texelDir));
			biasedResult.w += weight;
			vec3 rayRadiance = rayRadiance[rayIdx];
			biasedResult.xyz += rayRadiance * weight;
		}
		float epsilon = float(volume.fixedRayCount) * 1e-9f;
		float weightNormalization = 1.f/ (max(biasedResult.w, epsilon));
		biasedResult.xyz *= weightNormalization;
	}

	vec4 result = vec4(0.f);
	float resultWeight = 0.f;
	int rayIdx = 0;
	if ((volume.relocationEnabled != 0) || (volume.classificationEnabled != 0))
    {
		//Biased
        rayIdx = int(volume.fixedRayCount);
    }
	uint backfaceCount = 0;
	uint backfaceThreshold = uint(uint( rayCount - rayIdx) * volume.backfaceThreshold);

	for(; rayIdx < rayCount; rayIdx++) {

		vec3 rayDir = rayDirection[rayIdx];
		float rayDist = rayDistance[rayIdx];

		float weight = max(0.f, dot(rayDir, texelDir));
		resultWeight += weight;

		if(filterIrradiance) {
			if(rayDist < 0.f){
				++backfaceCount;
				if( backfaceCount > backfaceThreshold)
				{
					result.xyz = vec3(0.f);
					break;
					//return;
				}
				continue;
			}
			vec3 rayRadiance = rayRadiance[rayIdx];
			result += vec4(rayRadiance * weight, 0.f);
		}
		else {
			rayDist = min(abs(rayDist), 1);
			const float rayDistSqarred = rayDist * rayDist;
			result += vec4(rayDist, rayDistSqarred, rayDistSqarred * rayDist, rayDistSqarred * rayDistSqarred) * weight;
		}
	}
	float epsilon = float(rayCount) * 1e-9f;
	float hysteresis = volume.hysteresis;
	
	ivec3 texCoord = get_probe_texel_coords(ivec3(gl_WorkGroupID.xyz), ivec2(gl_WorkGroupSize.xy), volume);
	texCoord.xy += ivec2(gl_LocalInvocationID.xy);

	float weightNormalization = 1.f/ (max(resultWeight, epsilon));

	if(filterIrradiance)
		weightNormalization *= 0.5f;

	result *= weightNormalization;

	vec4 previous = vec4(0.f);
	uint imageBinding = 0;
	if(filterIrradiance)
		imageBinding = volume.irradianceImageBinding;
	else
		imageBinding = volume.depthImageBinding;
			
	if(imageFormat == R11G11B10F)
		previous = imageLoad(imagesArrayR11G11B10F[imageBinding], texCoord);
	else if(imageFormat == R10G10B10A2F)
		previous = imageLoad(imagesArrayRGB10_A2[imageBinding], texCoord);
	else if(imageFormat == R16G16B16A16F)
		previous = imageLoad(imagesArrayRGBA16F[imageBinding], texCoord);
	else if(imageFormat == R32G32B32A32F)
		previous = imageLoad(imagesArrayRGBA32F[imageBinding], texCoord);
	else if(imageFormat == E5B9G9R9F)
		previous.xyz = rgb9e5_to_vec3(imageLoad(imagesArrayR32UI[imageBinding], texCoord).x);
		//previous.xyz = rgb9e5_to_vec3(floatBitsToUint(imageLoad(imagesR32F[imageBinding], texCoord).x));

	//Recover if we somehow get negativ radiance
	//Shouldn't happen though
	if(dot(previous, previous) <= 0)
		hysteresis = 0.f;

	if(filterIrradiance) {
	
		#undef DO_GAMMA
		#define DO_GAMMA
		#ifdef DO_GAMMA
		result.rgb = pow(result.rgb, vec3(1.f / 5.f));
			
		biasedResult.rgb = pow(biasedResult.rgb, vec3(1.f / 5.f));
		#endif		

		//MultiscaleMeanEstimator from Ray Tracing Gems
		
		vec4 data0 = imageLoad(imagesArrayRGBA16F[volume.data0ImageBinding], texCoord);
		vec4 data1 = imageLoad(imagesArrayRGBA16F[volume.data1ImageBinding], texCoord);
		MultiscaleMeanEstimatorData data;

		//data.mean = data2.xyz;
		data.mean = previous.xyz;
		data.shortMean = data0.xyz;
		data.vbbr = data0.w;
		data.variance = data1.xyz;
		data.inconsistency = data1.w;

		//MultiscaleMeanEstimator(result.xyz, data, 0.08f);
		if(volume.biasedEstimator == 0) {
			data.mean = previous.xyz;
			MultiscaleMeanEstimator(result.xyz, data, volume.lightToDarkThreshold);
			result.xyz = data.mean;
		} else {
			vec4 data2 = imageLoad(imagesArrayRGBA16F[volume.data2ImageBinding], texCoord);
			data.mean = data2.xyz;
			float blendfactor = MultiscaleMeanEstimator(biasedResult.xyz, data, volume.lightToDarkThreshold);
			result = vec4(mix(previous.xyz, result.xyz, blendfactor), 1.f);
			imageStore(imagesArrayRGBA16F[volume.data2ImageBinding], texCoord, vec4(data.mean, blendfactor));
		}
		//float blendfactor = MultiscaleMeanEstimator(biasedResult.xyz, data, volume.lightToDarkThreshold);
		//float blendfactor = MultiscaleMeanEstimator(result.xyz, data, volume.lightToDarkThreshold);
		//result = vec4(mix(previous.xyz, result.xyz, blendfactor), 1.f);
		//result = vec4(mix(previous.xyz, biasedResult.xyz, blendfactor), 1.f);
		
		imageStore(imagesArrayRGBA16F[volume.data0ImageBinding], texCoord, vec4(data.shortMean, data.vbbr));
		imageStore(imagesArrayRGBA16F[volume.data1ImageBinding], texCoord, vec4(data.variance, data.inconsistency));

		if(dynamicRayAllocationEnabled) {
			//float variance = max_component(abs(data.variance));
			float variance = max_component(abs(data.variance / max(data.mean, 1e-6))); //relative Variance
			variance = subgroupInclusiveAdd(variance);//gl_SubgroupID 
			float totalVariance = 0.f;
			int finished = 0;
			if(subgroupElect()) {
				totalVariance = atomicAdd(rayVariance, variance) + variance;
			}
			//Since there's no guarantee that two atomics are executed in order
			barrier();
			if(gl_LocalInvocationIndex == 0)
				writeFloats[volume.dynamicRayBufferBinding].f[(probeCount) * 2 + probeIdx + 1] = rayVariance;
		}

	//Biased shadow-preserving temporal hysteresis. from GI-1.0
//		float l1 = dot(result.xyz, vec3(1.f / 3.f));
//		float l2 = dot(previous.xyz, vec3(1.f / 3.f));
//
//		float alpha = max(l1 - l2 - min(l1, l2), 0.f) / max(max(l1, l2), 1e-4f);
//		alpha = clamp(alpha, 0.f, 0.95f);
//		alpha *= alpha;
//
//		result = vec4(mix(result.xyz, previous.xyz, alpha), 1.f);


		// From the 2021 paper
//		vec3 delta = result.xyz - previous.xyz;
//
//		float changeMagnitude = max_component(abs(-delta));
//		
//		if(changeMagnitude > 0.25)
//			hysteresis = max(0.f, hysteresis - 0.15f);
//
//		if(changeMagnitude > 0.8)
//			hysteresis = 0.f;
//			
//
//		result.rgb = mix(result.rgb, previous.rgb, hysteresis);
//		result.a = 1.f;
//

		//From RTXGI SDK
//		vec3 delta = result.xyz - previous.xyz;
//		if(length(delta) > volume.lightToDarkThreshold)
//		{
//			result.rgb = previous.xyz + (delta * 0.25f);
//		}
//		
//		if(max_component(-delta) > volume.irradianceThreshold)
//		{
//			hysteresis = max(0.f, hysteresis - 0.75f);
//		}
//
//
//		const float threshold = 1.f / 1024.f;
//		vec3 lerpDelta = (1.f - hysteresis) * delta;
//		if(max_component(result.xyz) < max_component(previous.xyz))
//		{
//			lerpDelta = clamp(vec3(threshold), abs(lerpDelta), abs(delta)) * sign(lerpDelta);
//		}
//		result = vec4(previous.xyz + lerpDelta, 1.0f);



//Debug checkerboard pattern
//		result = vec4(0, 0, 0, 1);
//		if((((texCoord.x &0x1) == 1)|| ((texCoord.y &0x1) == 1)) && !(((texCoord.x &0x1) == 1) && ((texCoord.y &0x1) == 1)))
//			result = vec4(1, 1,1,1);
//		if((((gl_WorkGroupID.x &0x1) == 1)|| ((gl_WorkGroupID.y &0x1) == 1)) && !(((gl_WorkGroupID.x &0x1) == 1) && ((gl_WorkGroupID.y &0x1) == 1)))
//			result.xy = vec2(1, 0);
//		if((gl_WorkGroupID.z &0x1) == 1)
//			result.z = 1;
#ifdef DEBUG_COLORS
		result = debugColors[probeIdx % debugColors.length()];
#endif
		//result.xyz = vec3(0.1f);
	}
	else {
		result = vec4(mix(result, previous, hysteresis));
	}

	if(imageFormat == R11G11B10F)
		imageStore(imagesArrayR11G11B10F[imageBinding], texCoord, result);
	else if(imageFormat == R10G10B10A2F)
		imageStore(imagesArrayRGB10_A2[imageBinding], texCoord, result);
	else if(imageFormat == R16G16B16A16F)
		imageStore(imagesArrayRGBA16F[imageBinding], texCoord, result);
	else if(imageFormat == R32G32B32A32F)
		imageStore(imagesArrayRGBA32F[imageBinding], texCoord, result);
	else if(imageFormat == E5B9G9R9F)
		imageStore(imagesArrayR32UI[imageBinding], texCoord, uvec4(vec3_to_rgb9e5(result.rgb), 0, 0,0));
		//imageStore(imagesR32F[imageBinding], texCoord, vec4(uintBitsToFloat(vec3_to_rgb9e5(result.rgb)), 0, 0,0));
	
}