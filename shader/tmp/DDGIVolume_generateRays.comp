#version 430 // -*- c++ -*-
#ifdef GL_ARB_compute_variable_group_size
#extension GL_ARB_compute_variable_group_size : enable
#endif

#include <g3dmath.glsl>

#include "../DDGIVolume/DDGIVolume.glsl"

uniform DDGIVolume ddgiVolume;

layout(local_size_variable) in;

layout(rgba32f) uniform image2D rayOriginImage;
layout(rgba32f) uniform image2D rayDirectionImage;

layout(std430, binding = 2) restrict readonly buffer RayBlockIndexOffsetSSBO {
    int rayBlockOffset[];
};


/**  Generate a spherical fibonacci point
    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/
    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * pi * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}
//void DDGIVolumeBase::ComputeRandomRotation()
//{
//    // This approach is based on James Arvo's implementation from Graphics Gems 3 (pg 117-120).
//    // Also available at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&rep=rep1&type=pdf
//
//    // Setup a random rotation matrix using 3 uniform RVs
//    float u1 = RTXGI_2PI * GetRandomFloat();
//    float cos1 = cosf(u1);
//    float sin1 = sinf(u1);
//
//    float u2 = RTXGI_2PI * GetRandomFloat();
//    float cos2 = cosf(u2);
//    float sin2 = sinf(u2);
//
//    float u3 = GetRandomFloat();
//    float sq3 = 2.f * sqrtf(u3 * (1.f - u3));
//
//    float s2 = 2.f * u3 * sin2 * sin2 - 1.f;
//    float c2 = 2.f * u3 * cos2 * cos2 - 1.f;
//    float sc = 2.f * u3 * sin2 * cos2;
//
//    // Create the random rotation matrix
//    float _11 = cos1 * c2 - sin1 * sc;
//    float _12 = sin1 * c2 + cos1 * sc;
//    float _13 = sq3 * cos2;
//
//    float _21 = cos1 * sc - sin1 * s2;
//    float _22 = sin1 * sc + cos1 * s2;
//    float _23 = sq3 * sin2;
//
//    float _31 = cos1 * (sq3 * cos2) - sin1 * (sq3 * sin2);
//    float _32 = sin1 * (sq3 * cos2) + cos1 * (sq3 * sin2);
//    float _33 = 1.f - 2.f * u3;
//
//    // HLSL is column-major
//    float3x3 transform;
//    transform.r0 = { _11, _12, _13 };
//    transform.r1 = { _21, _22, _23 };
//    transform.r2 = { _31, _32, _33 };
//
//    m_probeRayRotationMatrix = transform;
//    m_probeRayRotationQuaternion = RotationMatrixToQuaternion(m_probeRayRotationMatrix);
//}
//

/**
    \param r Two uniform random numbers on [0,1]

    \return uniformly distributed random sample on unit sphere

    http://mathworld.wolfram.com/SpherePointPicking.html

    See also g3d_sphereRandom texture and sphericalFibonacci()
*/
vec3 sphereRandom(vec2 r) {
    float cosPhi = r.x * 2.0 - 1.0;
    float sinPhi = sqrt(1 - square(cosPhi));
    float theta = r.y * 2.0 * pi;
    return Vector3(sinPhi * cos(theta), sinPhi * cos(theta), cosPhi);
}

/**
    \param r Two uniform random numbers on [0,1]

  \return uniformly distributed random sample on unit hemisphere about +z
    See also hemisphereRandom texture.
*/
vec3 hemisphereRandom(vec2 r) {
    vec3 s = sphereRandom(r);
    return Vector3(s.x, s.y, abs(s.z));
}


/** Returns cos^k distributed random values distributed on the
    hemisphere about +z

    \param r Two uniform random numbers on [0,1]
    See also cosHemiRandom texture.
*/
vec3 cosPowHemiRandom(vec2 r, const float k) {
    float cos_theta = pow(r.x, 1.0 / (k + 1.0));
    float sin_theta = sqrt(1.0f - square(cos_theta));
    float phi = 2 * pi * r.y;

    return vec3( cos(phi) * sin_theta,
                    sin(phi) * sin_theta,
                    cos_theta);
}

uniform int2    gridSize;
uniform int     offset;

uniform int textureWidth;

// Assumed to be the x dimension of the output texture
#expect RAYS_PER_PROBE "int"

uniform mat3                    randomOrientation;

void main() {

    int idx = (int)gl_GlobalInvocationID.y * (int)gridSize.x + (int)gl_GlobalInvocationID.x;

	int probeID = idx / RAYS_PER_PROBE;
	int rayID   = idx % RAYS_PER_PROBE;

	float3 direction = randomOrientation * sphericalFibonacci(rayID, RAYS_PER_PROBE);

    int probeXY = ddgiVolume.probeCounts.x * ddgiVolume.probeCounts.y;

	ivec2 probeFlagTexCoord = ivec2(probeID % probeXY, probeID / probeXY);
	vec4 probeOffset = readProbeOffset(ddgiVolume, probeFlagTexCoord);

	float rayMaxDistance = inf;

    int sleepingProbes = rayBlockOffset[probeID];

    // Don't generate rays for skipped probes.
    if (sleepingProbes == -1) {
        return;
    }

    idx -= sleepingProbes * RAYS_PER_PROBE;

    // Don't bump the ray origin, as the probes cannot intersect themselves.
    // If we bump, we risk putting rays through walls when probes are close to walls.
    const float rayMinDistance = 0.000;
	int finalIndex = offset + idx;
	ivec2 texCoord = ivec2(finalIndex % textureWidth, finalIndex / textureWidth);

	imageStore(rayOriginImage, texCoord, float4(probeLocation(ddgiVolume, probeID), rayMinDistance));
	//rayOrigin[offset + idx] = float4(probeLocation(ddgiVolume, probeID), rayMinDistance);
    
	imageStore(rayDirectionImage, texCoord, float4(direction, rayMaxDistance));
	//rayDirection[offset + idx] = float4(direction, rayMaxDistance);
}
