#version 430 // -*- c++ -*-
#ifdef GL_ARB_compute_variable_group_size
#extension GL_ARB_compute_variable_group_size : enable
#endif

#include <g3dmath.glsl>

#include "../DDGIVolume/DDGIVolume.glsl"

uniform DDGIVolume ddgiVolume;

layout(local_size_variable) in;

layout(rgba32f) uniform image2D rayOriginImage;
layout(rgba32f) uniform image2D rayDirectionImage;

layout(std430, binding = 2) restrict readonly buffer RayBlockIndexOffsetSSBO {
    int rayBlockOffset[];
};


/**  Generate a spherical fibonacci point
    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/
    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * pi * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}
//void DDGIVolumeBase::ComputeRandomRotation()
//{
//    // This approach is based on James Arvo's implementation from Graphics Gems 3 (pg 117-120).
//    // Also available at: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.1357&rep=rep1&type=pdf
//
//    // Setup a random rotation matrix using 3 uniform RVs
//    float u1 = RTXGI_2PI * GetRandomFloat();
//    float cos1 = cosf(u1);
//    float sin1 = sinf(u1);
//
//    float u2 = RTXGI_2PI * GetRandomFloat();
//    float cos2 = cosf(u2);
//    float sin2 = sinf(u2);
//
//    float u3 = GetRandomFloat();
//    float sq3 = 2.f * sqrtf(u3 * (1.f - u3));
//
//    float s2 = 2.f * u3 * sin2 * sin2 - 1.f;
//    float c2 = 2.f * u3 * cos2 * cos2 - 1.f;
//    float sc = 2.f * u3 * sin2 * cos2;
//
//    // Create the random rotation matrix
//    float _11 = cos1 * c2 - sin1 * sc;
//    float _12 = sin1 * c2 + cos1 * sc;
//    float _13 = sq3 * cos2;
//
//    float _21 = cos1 * sc - sin1 * s2;
//    float _22 = sin1 * sc + cos1 * s2;
//    float _23 = sq3 * sin2;
//
//    float _31 = cos1 * (sq3 * cos2) - sin1 * (sq3 * sin2);
//    float _32 = sin1 * (sq3 * cos2) + cos1 * (sq3 * sin2);
//    float _33 = 1.f - 2.f * u3;
//
//    // HLSL is column-major
//    float3x3 transform;
//    transform.r0 = { _11, _12, _13 };
//    transform.r1 = { _21, _22, _23 };
//    transform.r2 = { _31, _32, _33 };
//
//    m_probeRayRotationMatrix = transform;
//    m_probeRayRotationQuaternion = RotationMatrixToQuaternion(m_probeRayRotationMatrix);
//}
//
///*
//* Copyright (c) 2019-2022, NVIDIA CORPORATION.  All rights reserved.
//*
//* NVIDIA CORPORATION and its licensors retain all intellectual property
//* and proprietary rights in and to this software, related documentation
//* and any modifications thereto.  Any use, reproduction, disclosure or
//* distribution of this software and related documentation without an express
//* license agreement from NVIDIA CORPORATION is strictly prohibited.
//*/
//
//#include "../include/Descriptors.hlsl"
//#include "../include/Lighting.hlsl"
//#include "../include/RayTracing.hlsl"
//
//#include "../../../../rtxgi-sdk/shaders/ddgi/Irradiance.hlsl"
//
//// ---[ Ray Generation Shader ]---
//
//[shader("raygeneration")]
//void RayGen()
//{
//    uint2 DispatchIndex = DispatchRaysIndex().xy;
//    int rayIndex = DispatchIndex.x;                    // index of the current probe ray
//    int probeIndex = DispatchIndex.y;                  // index of current probe
//
//    // Get the DDGIVolume's index
//#if SPIRV
//    uint volumeIndex = Global.ddgi_volumeIndex;
//#else
//    uint volumeIndex = DDGI.volumeIndex;
//#endif
//
//    // Get the DDGIVolume's constants
//    DDGIVolumeDescGPU volume = UnpackDDGIVolumeDescGPU(DDGIVolumes[volumeIndex]);
//
//    // Get the probe's grid coordinates
//    float3 probeCoords = DDGIGetProbeCoords(probeIndex, volume);
//
//    // Adjust the probe index for the scroll offsets
//    probeIndex = DDGIGetScrollingProbeIndex(probeCoords, volume);
//
//    // Get the probe data texture
//    Texture2D<float4> ProbeData = GetDDGIVolumeProbeDataSRV(volumeIndex);
//
//    // Get the probe's state
//    float probeState = DDGILoadProbeState(probeIndex, ProbeData, volume);
//
//    // Early out: do not shoot rays when the probe is inactive *unless* it is one of the "fixed" rays used by probe classification
//    if (probeState == RTXGI_DDGI_PROBE_STATE_INACTIVE && rayIndex >= RTXGI_DDGI_NUM_FIXED_RAYS) return;
//
//    // Get the probe's world position
//    // Note: world positions are computed from probe coordinates *not* adjusted for infinite scrolling
//    float3 probeWorldPosition = DDGIGetProbeWorldPosition(probeCoords, volume, ProbeData);
//
//    // Get a random normalized ray direction to use for a probe ray
//    float3 probeRayDirection = DDGIGetProbeRayDirection(rayIndex, volume);
//
//    // Texture output coordinates
//    // Note: probe index is the scroll adjusted index (if scrolling is enabled)
//    uint2 texCoords = uint2(rayIndex, probeIndex);
//
//    // Setup the probe ray
//    RayDesc ray;
//    ray.Origin = probeWorldPosition;
//    ray.Direction = probeRayDirection;
//    ray.TMin = 0.f;
//    ray.TMax = volume.probeMaxRayDistance;
//
//    // Setup the ray payload
//    PackedPayload packedPayload = (PackedPayload)0;
//
//    // If classification is enabled, pass the probe's state to hit shaders through the payload
//    if(volume.probeClassificationEnabled) packedPayload.packed0.x = probeState;
//
//    // Trace the Probe Ray
//    TraceRay(
//        SceneBVH,
//        RAY_FLAG_NONE,
//        0xFF,
//        0,
//        1,
//        0,
//        ray,
//        packedPayload);
//
//    // Get the ray data texture
//    RWTexture2D<float4> RayData = GetDDGIVolumeRayDataUAV(volumeIndex);
//
//    // The ray missed. Store the miss radiance, set the hit distance to a large value, and exit early.
//    if (packedPayload.hitT < 0.f)
//    {
//        // Store the ray miss
//        DDGIStoreProbeRayMiss(RayData, texCoords, volume, GetGlobalConst(app, skyRadiance));
//        return;
//    }
//
//    // Unpack the payload
//    Payload payload = UnpackPayload(packedPayload);
//
//    // The ray hit a surface backface.
//    if (payload.hitKind == HIT_KIND_TRIANGLE_BACK_FACE)
//    {
//        // Store the ray backface hit
//        DDGIStoreProbeRayBackfaceHit(RayData, texCoords, volume, payload.hitT);
//        return;
//    }
//
//    // Early out: a "fixed" ray hit a front facing surface. Fixed rays are not blended since their direction
//    // is not random and they would bias the irradiance estimate. Don't perform lighting for these rays.
//    if((volume.probeRelocationEnabled || volume.probeClassificationEnabled) && rayIndex < RTXGI_DDGI_NUM_FIXED_RAYS)
//    {
//        // Store the ray front face hit distance (only)
//        DDGIStoreProbeRayFrontfaceHit(RayData, texCoords, volume, payload.hitT);
//        return;
//    }
//
//    // Direct Lighting and Shadowing
//    float3 diffuse = DirectDiffuseLighting(payload, GetGlobalConst(pt, rayNormalBias), GetGlobalConst(pt, rayViewBias), SceneBVH);
//
//    // Indirect Lighting (recursive)
//    float3 irradiance = 0.f;
//    float3 surfaceBias = DDGIGetSurfaceBias(payload.normal, ray.Direction, volume);
//
//    // Setup the volume resources needed for the irradiance query
//    DDGIVolumeResources resources;
//    resources.probeIrradiance = GetDDGIVolumeIrradianceSRV(volumeIndex);
//    resources.probeDistance = GetDDGIVolumeDistanceSRV(volumeIndex);
//    resources.probeData = GetDDGIVolumeProbeDataSRV(volumeIndex);
//    resources.bilinearSampler = GetBilinearWrapSampler();
//
//    // Compute volume blending weight
//    float volumeBlendWeight = DDGIGetVolumeBlendWeight(payload.worldPosition, volume);
//
//    // Don't evaluate irradiance when the surface is outside the volume
//    if (volumeBlendWeight > 0)
//    {
//        // Get irradiance from the DDGIVolume
//        irradiance = DDGIGetVolumeIrradiance(
//            payload.worldPosition,
//            surfaceBias,
//            payload.normal,
//            volume,
//            resources);
//
//        // Attenuate irradiance by the blend weight
//        irradiance *= volumeBlendWeight;
//    }
//
//    // Perfectly diffuse reflectors don't exist in the real world.
//    // Limit the BRDF albedo to a maximum value to account for the energy loss at each bounce.
//    float maxAlbedo = 0.9f;
//
//    // Store the final ray radiance and hit distance
//    float3 radiance = diffuse + ((min(payload.albedo, float3(maxAlbedo, maxAlbedo, maxAlbedo)) / PI) * irradiance);
//    DDGIStoreProbeRayFrontfaceHit(RayData, texCoords, volume, radiance, payload.hitT);
//}

/**
    \param r Two uniform random numbers on [0,1]

    \return uniformly distributed random sample on unit sphere

    http://mathworld.wolfram.com/SpherePointPicking.html

    See also g3d_sphereRandom texture and sphericalFibonacci()
*/
vec3 sphereRandom(vec2 r) {
    float cosPhi = r.x * 2.0 - 1.0;
    float sinPhi = sqrt(1 - square(cosPhi));
    float theta = r.y * 2.0 * pi;
    return Vector3(sinPhi * cos(theta), sinPhi * cos(theta), cosPhi);
}

/**
    \param r Two uniform random numbers on [0,1]

  \return uniformly distributed random sample on unit hemisphere about +z
    See also hemisphereRandom texture.
*/
vec3 hemisphereRandom(vec2 r) {
    vec3 s = sphereRandom(r);
    return Vector3(s.x, s.y, abs(s.z));
}


/** Returns cos^k distributed random values distributed on the
    hemisphere about +z

    \param r Two uniform random numbers on [0,1]
    See also cosHemiRandom texture.
*/
vec3 cosPowHemiRandom(vec2 r, const float k) {
    float cos_theta = pow(r.x, 1.0 / (k + 1.0));
    float sin_theta = sqrt(1.0f - square(cos_theta));
    float phi = 2 * pi * r.y;

    return vec3( cos(phi) * sin_theta,
                    sin(phi) * sin_theta,
                    cos_theta);
}

uniform int2    gridSize;
uniform int     offset;

uniform int textureWidth;

// Assumed to be the x dimension of the output texture
#expect RAYS_PER_PROBE "int"

uniform mat3                    randomOrientation;

void main() {

    int idx = (int)gl_GlobalInvocationID.y * (int)gridSize.x + (int)gl_GlobalInvocationID.x;

	int probeID = idx / RAYS_PER_PROBE;
	int rayID   = idx % RAYS_PER_PROBE;

	float3 direction = randomOrientation * sphericalFibonacci(rayID, RAYS_PER_PROBE);

    int probeXY = ddgiVolume.probeCounts.x * ddgiVolume.probeCounts.y;

	ivec2 probeFlagTexCoord = ivec2(probeID % probeXY, probeID / probeXY);
	vec4 probeOffset = readProbeOffset(ddgiVolume, probeFlagTexCoord);

	float rayMaxDistance = inf;

    int sleepingProbes = rayBlockOffset[probeID];

    // Don't generate rays for skipped probes.
    if (sleepingProbes == -1) {
        return;
    }

    idx -= sleepingProbes * RAYS_PER_PROBE;

    // Don't bump the ray origin, as the probes cannot intersect themselves.
    // If we bump, we risk putting rays through walls when probes are close to walls.
    const float rayMinDistance = 0.000;
	int finalIndex = offset + idx;
	ivec2 texCoord = ivec2(finalIndex % textureWidth, finalIndex / textureWidth);

	imageStore(rayOriginImage, texCoord, float4(probeLocation(ddgiVolume, probeID), rayMinDistance));
	//rayOrigin[offset + idx] = float4(probeLocation(ddgiVolume, probeID), rayMinDistance);
    
	imageStore(rayDirectionImage, texCoord, float4(direction, rayMaxDistance));
	//rayDirection[offset + idx] = float4(direction, rayMaxDistance);
}
