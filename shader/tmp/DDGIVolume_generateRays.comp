#version 430 // -*- c++ -*-
#ifdef GL_ARB_compute_variable_group_size
#extension GL_ARB_compute_variable_group_size : enable
#endif

#include <g3dmath.glsl>

#include "../DDGIVolume/DDGIVolume.glsl"

uniform DDGIVolume ddgiVolume;

layout(local_size_variable) in;

layout(rgba32f) uniform image2D rayOriginImage;
layout(rgba32f) uniform image2D rayDirectionImage;

layout(std430, binding = 2) restrict readonly buffer RayBlockIndexOffsetSSBO {
    int rayBlockOffset[];
};


/**  Generate a spherical fibonacci point
    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/
    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
vec3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * pi * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

    return vec3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}

/**
    \param r Two uniform random numbers on [0,1]

    \return uniformly distributed random sample on unit sphere

    http://mathworld.wolfram.com/SpherePointPicking.html

    See also g3d_sphereRandom texture and sphericalFibonacci()
*/
vec3 sphereRandom(vec2 r) {
    float cosPhi = r.x * 2.0 - 1.0;
    float sinPhi = sqrt(1 - square(cosPhi));
    float theta = r.y * 2.0 * pi;
    return Vector3(sinPhi * cos(theta), sinPhi * cos(theta), cosPhi);
}

/**
    \param r Two uniform random numbers on [0,1]

  \return uniformly distributed random sample on unit hemisphere about +z
    See also hemisphereRandom texture.
*/
vec3 hemisphereRandom(vec2 r) {
    vec3 s = sphereRandom(r);
    return Vector3(s.x, s.y, abs(s.z));
}


/** Returns cos^k distributed random values distributed on the
    hemisphere about +z

    \param r Two uniform random numbers on [0,1]
    See also cosHemiRandom texture.
*/
vec3 cosPowHemiRandom(vec2 r, const float k) {
    float cos_theta = pow(r.x, 1.0 / (k + 1.0));
    float sin_theta = sqrt(1.0f - square(cos_theta));
    float phi = 2 * pi * r.y;

    return vec3( cos(phi) * sin_theta,
                    sin(phi) * sin_theta,
                    cos_theta);
}

uniform int2    gridSize;
uniform int     offset;

uniform int textureWidth;

// Assumed to be the x dimension of the output texture
#expect RAYS_PER_PROBE "int"

uniform mat3                    randomOrientation;

void main() {

    int idx = (int)gl_GlobalInvocationID.y * (int)gridSize.x + (int)gl_GlobalInvocationID.x;

	int probeID = idx / RAYS_PER_PROBE;
	int rayID   = idx % RAYS_PER_PROBE;

	float3 direction = randomOrientation * sphericalFibonacci(rayID, RAYS_PER_PROBE);

    int probeXY = ddgiVolume.probeCounts.x * ddgiVolume.probeCounts.y;

	ivec2 probeFlagTexCoord = ivec2(probeID % probeXY, probeID / probeXY);
	vec4 probeOffset = readProbeOffset(ddgiVolume, probeFlagTexCoord);

	float rayMaxDistance = inf;

    int sleepingProbes = rayBlockOffset[probeID];

    // Don't generate rays for skipped probes.
    if (sleepingProbes == -1) {
        return;
    }

    idx -= sleepingProbes * RAYS_PER_PROBE;

    // Don't bump the ray origin, as the probes cannot intersect themselves.
    // If we bump, we risk putting rays through walls when probes are close to walls.
    const float rayMinDistance = 0.000;
	int finalIndex = offset + idx;
	ivec2 texCoord = ivec2(finalIndex % textureWidth, finalIndex / textureWidth);

	imageStore(rayOriginImage, texCoord, float4(probeLocation(ddgiVolume, probeID), rayMinDistance));
	//rayOrigin[offset + idx] = float4(probeLocation(ddgiVolume, probeID), rayMinDistance);
    
	imageStore(rayDirectionImage, texCoord, float4(direction, rayMaxDistance));
	//rayDirection[offset + idx] = float4(direction, rayMaxDistance);
}
